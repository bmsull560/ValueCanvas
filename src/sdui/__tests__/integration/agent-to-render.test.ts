/**
 * Task #011: Integration Testing - Agent → SDUI → Render
 * 
 * Tests the complete flow:
 * 1. Agent generates layout → CanvasStore receives
 * 2. CanvasPatcher applies delta → UI updates
 * 3. User undoes → History rewinds
 * 4. Error handling → Graceful degradation
 */

import { describe, it, expect, beforeEach, vi } from 'vitest';
import { renderPage } from '../../engine/renderPage';
import { useCanvasStore } from '../../canvas/CanvasStore';
import { SDUIPageDefinition } from '../../schema';
import React from 'react';

describe('Agent to Render Integration Tests', () => {
  beforeEach(() => {
    // Reset canvas store before each test
    const store = useCanvasStore.getState();
    store.reset();
  });

  describe('Test 1: Agent generates layout → CanvasStore receives', () => {
    it('should accept agent-generated layout and store it', () => {
      // Simulate agent output
      const agentLayout: SDUIPageDefinition = {
        type: 'page',
        version: 1,
        sections: [
          {
            type: 'component',
            component: 'PageHeader',
            version: 1,
            props: {
              title: 'Test Page',
              subtitle: 'Generated by OpportunityAgent',
            },
          },
          {
            type: 'layout.directive',
            intent: 'Show opportunity analysis',
            component: 'OpportunityCard',
            props: {
              opportunity: 'Test opportunity',
              confidence: 0.85,
            },
            layout: 'default',
            metadata: {
              agentId: 'opportunity-v1',
            },
          },
        ],
        metadata: {
          debug: false,
          experienceId: 'test-123',
        },
      };

      // Store receives layout
      const store = useCanvasStore.getState();
      store.setCurrentPage(agentLayout);

      // Verify storage
      const storedPage = store.currentPage;
      expect(storedPage).toBeDefined();
      expect(storedPage?.sections).toHaveLength(2);
      expect(storedPage?.sections[0].component).toBe('PageHeader');
      expect(storedPage?.sections[1].type).toBe('layout.directive');
    });

    it('should track page in history', () => {
      const agentLayout: SDUIPageDefinition = {
        type: 'page',
        version: 1,
        sections: [
          {
            type: 'component',
            component: 'TestComponent',
            version: 1,
            props: {},
          },
        ],
        metadata: {
          experienceId: 'test-456',
        },
      };

      const store = useCanvasStore.getState();
      store.setCurrentPage(agentLayout);

      // Verify history tracking
      expect(store.canUndo()).toBe(false); // First page, nothing to undo to
      expect(store.history).toHaveLength(1);
    });
  });

  describe('Test 2: CanvasPatcher applies delta → UI updates', () => {
    it('should apply incremental updates to existing page', () => {
      // Initial page
      const initialPage: SDUIPageDefinition = {
        type: 'page',
        version: 1,
        sections: [
          {
            type: 'component',
            component: 'StatusCard',
            version: 1,
            props: {
              status: 'loading',
            },
          },
        ],
        metadata: {
          experienceId: 'test-delta',
        },
      };

      const store = useCanvasStore.getState();
      store.setCurrentPage(initialPage);

      // Apply delta (status update)
      const updatedPage: SDUIPageDefinition = {
        ...initialPage,
        sections: [
          {
            ...initialPage.sections[0],
            props: {
              status: 'complete',
              result: 'Analysis finished',
            },
          },
        ],
      };

      store.setCurrentPage(updatedPage);

      // Verify update
      const current = store.currentPage;
      expect(current?.sections[0].props.status).toBe('complete');
      expect(current?.sections[0].props.result).toBe('Analysis finished');

      // Verify history
      expect(store.canUndo()).toBe(true);
    });

    it('should handle streaming updates', () => {
      const store = useCanvasStore.getState();

      // Streaming update 1
      const page1: SDUIPageDefinition = {
        type: 'page',
        version: 1,
        sections: [
          {
            type: 'component',
            component: 'ProgressBar',
            version: 1,
            props: { progress: 0.3, message: 'Analyzing...' },
          },
        ],
        metadata: { experienceId: 'stream' },
      };
      store.setCurrentPage(page1);

      // Streaming update 2
      const page2: SDUIPageDefinition = {
        ...page1,
        sections: [
          {
            ...page1.sections[0],
            props: { progress: 0.7, message: 'Processing...' },
          },
        ],
      };
      store.setCurrentPage(page2);

      // Final update
      const page3: SDUIPageDefinition = {
        ...page1,
        sections: [
          {
            type: 'component',
            component: 'ResultCard',
            version: 1,
            props: { result: 'Complete' },
          },
        ],
      };
      store.setCurrentPage(page3);

      // Verify final state
      expect(store.currentPage?.sections[0].component).toBe('ResultCard');
      expect(store.history).toHaveLength(3);
    });
  });

  describe('Test 3: User undoes → History rewinds', () => {
    it('should undo to previous page state', () => {
      const store = useCanvasStore.getState();

      // Page 1
      const page1: SDUIPageDefinition = {
        type: 'page',
        version: 1,
        sections: [{ type: 'component', component: 'A', version: 1, props: {} }],
        metadata: { experienceId: '1' },
      };
      store.setCurrentPage(page1);

      // Page 2
      const page2: SDUIPageDefinition = {
        type: 'page',
        version: 1,
        sections: [{ type: 'component', component: 'B', version: 1, props: {} }],
        metadata: { experienceId: '2' },
      };
      store.setCurrentPage(page2);

      // Page 3
      const page3: SDUIPageDefinition = {
        type: 'page',
        version: 1,
        sections: [{ type: 'component', component: 'C', version: 1, props: {} }],
        metadata: { experienceId: '3' },
      };
      store.setCurrentPage(page3);

      // Current should be C
      expect(store.currentPage?.sections[0].component).toBe('C');

      // Undo once
      store.undo();
      expect(store.currentPage?.sections[0].component).toBe('B');

      // Undo again
      store.undo();
      expect(store.currentPage?.sections[0].component).toBe('A');

      // Can't undo further
      expect(store.canUndo()).toBe(false);
    });

    it('should redo after undo', () => {
      const store = useCanvasStore.getState();

      const page1: SDUIPageDefinition = {
        type: 'page',
        version: 1,
        sections: [{ type: 'component', component: 'X', version: 1, props: {} }],
        metadata: { experienceId: 'x' },
      };
      const page2: SDUIPageDefinition = {
        type: 'page',
        version: 1,
        sections: [{ type: 'component', component: 'Y', version: 1, props: {} }],
        metadata: { experienceId: 'y' },
      };

      store.setCurrentPage(page1);
      store.setCurrentPage(page2);

      // Undo
      store.undo();
      expect(store.currentPage?.sections[0].component).toBe('X');

      // Redo
      store.redo();
      expect(store.currentPage?.sections[0].component).toBe('Y');
      expect(store.canRedo()).toBe(false);
    });

    it('should clear redo history on new change', () => {
      const store = useCanvasStore.getState();

      const page1: SDUIPageDefinition = {
        type: 'page',
        version: 1,
        sections: [{ type: 'component', component: 'P1', version: 1, props: {} }],
        metadata: { experienceId: 'p1' },
      };
      const page2: SDUIPageDefinition = {
        type: 'page',
        version: 1,
        sections: [{ type: 'component', component: 'P2', version: 1, props: {} }],
        metadata: { experienceId: 'p2' },
      };
      const page3: SDUIPageDefinition = {
        type: 'page',
        version: 1,
        sections: [{ type: 'component', component: 'P3', version: 1, props: {} }],
        metadata: { experienceId: 'p3' },
      };

      store.setCurrentPage(page1);
      store.setCurrentPage(page2);
      store.undo(); // Back to P1

      // Make new change - should clear redo
      store.setCurrentPage(page3);
      expect(store.canRedo()).toBe(false);
      expect(store.currentPage?.sections[0].component).toBe('P3');
    });
  });

  describe('Test 4: Error handling → Graceful degradation', () => {
    it('should render error fallback for invalid layout', () => {
      const invalidLayout: any = {
        type: 'page',
        version: 1,
        sections: [
          {
            type: 'component',
            // Missing component name
            props: {},
          },
        ],
      };

      // Mock component registry
      const registry = new Map();

      // Should not throw, should use error fallback
      expect(() => {
        renderPage(invalidLayout, { componentRegistry: registry });
      }).not.toThrow();
    });

    it('should handle missing components gracefully', () => {
      const layoutWithMissingComponent: SDUIPageDefinition = {
        type: 'page',
        version: 1,
        sections: [
          {
            type: 'component',
            component: 'NonExistentComponent',
            version: 1,
            props: {},
          },
        ],
        metadata: {
          experienceId: 'missing-test',
        },
      };

      const registry = new Map();
      // Component not registered

      const result = renderPage(layoutWithMissingComponent, {
        componentRegistry: registry,
      });

      // Should return an element (error fallback)
      expect(result).toBeDefined();
      expect(result.element).toBeDefined();
    });

    it('should use fallback component when specified', () => {
      const layoutWithFallback: SDUIPageDefinition = {
        type: 'page',
        version: 1,
        sections: [
          {
            type: 'component',
            component: 'PrimaryComponent',
            version: 1,
            props: {},
            fallback: {
              component: 'FallbackComponent',
              props: { message: 'Using fallback' },
            },
          },
        ],
        metadata: {
          experienceId: 'fallback-test',
        },
      };

      const registry = new Map();
      // PrimaryComponent not registered
      registry.set(
        'FallbackComponent',
        ({ message }: any) => React.createElement('div', null, message)
      );

      const result = renderPage(layoutWithFallback, {
        componentRegistry: registry,
      });

      expect(result.element).toBeDefined();
      // Fallback should be used
    });

    it('should capture and log render errors', () => {
      const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {});

      const componentThatThrows = () => {
        throw new Error('Render error test');
      };

      const layout: SDUIPageDefinition = {
        type: 'page',
        version: 1,
        sections: [
          {
            type: 'component',
            component: 'ThrowingComponent',
            version: 1,
            props: {},
          },
        ],
        metadata: { experienceId: 'error-test' },
      };

      const registry = new Map();
      registry.set('ThrowingComponent', componentThatThrows);

      const onError = vi.fn();

      renderPage(layout, {
        componentRegistry: registry,
        onError,
      });

      // Error should be caught and handled
      expect(onError).toHaveBeenCalled();

      consoleSpy.mockRestore();
    });
  });

  describe('Integration: Complete workflow', () => {
    it('should handle full agent → render → undo → redo cycle', () => {
      const store = useCanvasStore.getState();

      // Step 1: Agent generates initial layout
      const agentLayout1: SDUIPageDefinition = {
        type: 'page',
        version: 1,
        sections: [
          {
            type: 'component',
            component: 'OpportunityCard',
            version: 1,
            props: { title: 'Opportunity 1' },
          },
        ],
        metadata: { experienceId: 'opp-1' },
      };

      store.setCurrentPage(agentLayout1);
      const rendered1 = renderPage(agentLayout1);
      expect(rendered1.element).toBeDefined();

      // Step 2: Agent generates updated layout
      const agentLayout2: SDUIPageDefinition = {
        type: 'page',
        version: 1,
        sections: [
          {
            type: 'component',
            component: 'OpportunityCard',
            version: 1,
            props: { title: 'Opportunity 2 - Updated' },
          },
        ],
        metadata: { experienceId: 'opp-2' },
      };

      store.setCurrentPage(agentLayout2);
      const rendered2 = renderPage(agentLayout2);
      expect(rendered2.element).toBeDefined();

      // Step 3: User undoes
      expect(store.canUndo()).toBe(true);
      store.undo();

      // Should be back to layout 1
      const currentAfterUndo = store.currentPage;
      expect(currentAfterUndo?.sections[0].props.title).toBe('Opportunity 1');

      // Step 4: User redoes
      expect(store.canRedo()).toBe(true);
      store.redo();

      // Should be back to layout 2
      const currentAfterRedo = store.currentPage;
      expect(currentAfterRedo?.sections[0].props.title).toBe('Opportunity 2 - Updated');
    });
  });
});
